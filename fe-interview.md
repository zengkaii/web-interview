# [语雀面试集合，点击查看](https://www.yuque.com/12312wo/xqvhf0/gorg4wsw1vzt2kp5)

# 自我总结![alt text](24A2BC1D.png)

# vue相关

* [nextTick](#nexttick)
* [diff相关问题](#diff相关问题)
* [computed&watch](#computed与watch)
* [keep-alive](#keep-alive)
* [路由](#路由)
* 组件通信
* 路由
* vuex跟pinia

## nextTick

### 结合`mounted`
  
      1、在 mounted 钩子中直接获取元素的高度通常是可行的，但是在某些情况下可能会出现获取不到的情况，这取决于元素何时被渲染并且其高度何时被计算。mounted 钩子表示 Vue 实例已经挂载到 DOM 上，但并不能保证此时 DOM 元素已经完全渲染并且其高度已经计算完成。

      2、在某些情况下，特别是涉及到异步操作或者在数据更新后需要重新计算布局的情况下，直接在 mounted 钩子中获取元素的高度可能会导致获取到的高度不准确。这时候就需要使用 $nextTick 方法确保在 Vue 更新 DOM 后再获取元素的高度，以保证高度的准确性。

      3、因此，尽管在一些简单情况下直接在 mounted 钩子中获取元素的高度可能是可行的，但是为了更可靠地获取元素的高度，建议在 mounted 钩子中使用 $nextTick 方法或者将获取高度的操作放在其他适当的生命周期钩子中，以确保在 DOM 渲染完毕后再进行操作。

### 对比`setTimeout`

* 时机问题

        - `$nextTick`：将回调函数放入 Vue 的异步更新队列中，在下一次 DOM 更新循环之后执行。这意味着它会在 Vue 完成当前数据变化的同步更新之后，下一次 DOM 更新之前执行。

        - `setTimeout`：将回调函数放入 JavaScript 的异步任务队列中，在当前执行栈中的任务完成后执行。这意味着它的执行时机相对不稳定，可能在 Vue 的 DOM 更新之前或之后执行。

* 性能和效率

        - `$nextTick`：利用了 Vue 的内部机制，因此通常更高效。它只会在需要时执行回调函数，并且会在 Vue 的更新周期内进行调度，以确保在恰当的时候执行。

        - `setTimeout`：作为浏览器提供的通用异步机制，可能会稍微低效一些，因为它将任务添加到了浏览器的异步队列中，没有像 $nextTick 那样与 Vue 更新周期相关联。

  nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。简而言之，$nextTick 的实现原理就是将回调函数添加到 Vue 的异步队列中，在适当的时机执行这些回调函数，以确保在 DOM 更新完成后执行相应的操作。这种机制保证了 Vue 的响应性和高效性，同时也能够避免一些潜在的异步更新问题。

## diff相关问题

### 虚拟dom

    虚拟 DOM 是一个 JavaScript 对象表示的 DOM 树的抽象。Vue.js 和 React.js 等库使用虚拟 DOM 来进行高效的 DOM 更新。在每次数据变化时，这些库会先更新虚拟 DOM，然后通过 diff 算法确定实际需要更新的 DOM 节点，最后进行 DOM 操作。

### 当更新一个 v-for 渲染的列表时，Vue 的 diff 算法会执行以下步骤

* `创建新的虚拟 DOM 树：`当列表数据发生变化时，Vue 会根据最新的数据重新生成一个新的虚拟 DOM 树。

* `遍历新旧虚拟 DOM 树：`Vue 开始遍历新旧两个虚拟 DOM 树，对比它们的节点以确定变化。

* `比较相同位置的节点：`Vue 首先比较新旧列表中相同位置的节点。如果它们是同一个节点（即拥有相同的 key），则比较它们的内容是否相同，如果内容不同，则更新 DOM，否则不进行任何操作。

* `处理新增的节点和移除的节点：`如果新的虚拟 DOM 树中有新增的节点，或者旧的虚拟 DOM 树中有被移除的节点，Vue 会相应地执行 DOM 操作指令，插入新的节点或移除旧的节点。

* `处理需要移动的节点：`如果新的虚拟 DOM 树中的节点在旧的虚拟 DOM 树中找不到，或者节点的顺序发生变化，Vue 会标记这些节点需要被移动，然后执行 DOM 操作指令，将它们移动到正确的位置。

* `更新子节点：`如果某个节点有子节点（例如列表的每一项），Vue 会递归地对子节点进行相同的比较和更新操作。

## computed与watch

### computed

* computed 属性用于根据已有的数据计算出一个新的值，并且这个值会被缓存，只有相关的响应式数据发生变化时，才会重新计算。

### watch

* watch 用于监听某个数据的变化，在数据发生变化时执行一些特定的操作。

### 两者区别

* `依赖：`computed 属性是根据响应式数据自动追踪依赖，并在依赖变化时重新计算；而 watch 需要显式地指定要监听的数据。

* `适用场景：`computed 适用于衍生出一些依赖于其他响应式数据的值，而 watch 适用于需要执行异步或开销较大的操作，或者需要在数据变化时执行一些特定的逻辑。

* `返回值：`computed 返回一个计算得到的值，而 watch 并不返回任何值，而是在数据变化时执行回调函数。

* `异步操作：`由于 watch 可以监听到任何数据的变化，因此可以用于执行异步操作，而 computed 不支持异步操作。

## keep-alive

* 虚拟 DOM：Vue.js 使用虚拟 DOM 来管理组件的渲染和更新过程。每个组件都有对应的虚拟 DOM 树，在组件渲染时，Vue.js 会根据虚拟 DOM 树生成实际的 DOM。

* 组件缓存：当使用 keep-alive 包裹一个组件时，该组件在被激活后不会被销毁，而是会被缓存起来。这意味着当组件被切换到其他组件后，它的状态和 DOM 结构不会丢失，只是被隐藏了起来。

* 缓存对象采用了 LRUCache（Least Recently Used，最近最少使用）算法，确保当缓存空间达到一定限制时，会自动销毁最久未被使用的组件实例，以释放内存。

[查看语雀keep-alive](https://www.yuque.com/12312wo/xqvhf0/gorg4wsw1vzt2kp5#f37626a7)

缓存渲染的时候，会根据 vnode.componentInstance（首次渲染 vnode.componentInstance 为 undefined） 和 keepAlive 属性判断不会执行组件的 created、mounted 等钩子函数，而是对缓存的组件执行 patch 过程∶ 直接把缓存的 DOM 对象直接插入到目标元素中，完成了数据更新的情况下的渲染过程。

## 路由

### 路由模式

* 哈希模式（Hash mode）：

        默认的路由模式是哈希模式，在 URL 中使用 # 符号来作为路由的标记。例如：http://example.com/#/home。
        -哈希模式的优点是兼容性较好，因为哈希部分不会被发送到服务器，只会在客户端进行处理。
        -缺点是 URL 中的 # 符号看起来不太美观，并且在一些特定场景下可能会引起 SEO 问题。

* 历史模式（History mode）：

        历史模式使用 HTML5 提供的 history.pushState API 来实现路由，去掉了 URL 中的 # 符号。例如：http://example.com/home。
        -历史模式的优点是 URL 更加美观，更符合用户的预期，同时对 SEO 更友好。
        -缺点是需要服务器支持，因为路由的路径会被发送到服务器，如果在没有正确配置的情况下刷新页面，可能会导致 404 错误。（如何解决？）

### 动态路由

* 动态路由允许在路由路径中包含参数，这些参数的值是动态的，可以根据用户的输入或其他条件变化而变化。

* 在 Vue Router 中，使用冒号 : 表示动态参数，这样的路由路径被称为动态路由。

* 例如，/user/:id 是一个动态路由，其中的 :id 就是一个动态参数，表示用户的 ID。这样的路由可以匹配类似 /user/123、/user/456 这样的路径。

### 嵌套路由

* 嵌套路由允许在一个路由中嵌套另一个路由，从而形成父子关系，使得路由的结构更加清晰和灵活。
* 在 Vue Router 中，可以在组件内部定义子路由，然后在父路由中指定子路由的路径和组件。
* 例如，可以在一个名为 User 的父路由中嵌套多个子路由，如 UserPosts、UserProfile，分别对应用户的帖子页面和用户资料页面。

### 子路由

* 子路由是嵌套在父路由内部的路由，它们的路径是相对于父路由的路径的。
* 子路由可以有自己的路由规则和组件，也可以共享父路由的组件。
* 例如，在 User 父路由中可以定义一个子路由 /posts 和 /profile，分别对应用户的帖子页面和用户资料页面。

# 浏览器优化相关

* [前端性能关键指标](#前端性能关键指标)
* [性能优化](#性能优化)

## 前端性能关键指标

* `页面加载时间（Page Load Time）：`页面加载时间是指从用户请求网页开始到网页完全加载并可交互的时间。较短的页面加载时间可以提高用户的满意度和留存率。可以使用工具如Chrome开发者工具的Network面板、Lighthouse、WebPageTest等来监控页面加载时间，并通过优化资源加载、减少请求次数、使用CDN等手段来改进页面加载性能。

* `首次内容渲染时间（First Contentful Paint，FCP）：`FCP指的是浏览器首次绘制页面的时间，即用户能够看到页面的第一个内容的时间点。较快的FCP可以提高用户的感知速度和交互体验。可以通过Chrome开发者工具的Performance面板、Lighthouse等工具来监控和改进FCP，例如通过减少关键资源的加载时间、优化CSS和JavaScript的渲染等来提升FCP。

* `首次有意义交互时间（First Meaningful Paint，FMP）：`FMP指的是用户首次能够与页面进行有意义的交互的时间，例如页面上出现的主要内容或功能。较快的FMP可以增强用户的交互体验和参与度。可以通过Chrome开发者工具的Performance面板、Lighthouse等工具来监控和改进FMP，例如通过优化关键资源的加载顺序、减少渲染阻塞等来提升FMP。

* `用户交互响应时间（Time to Interactive，TTI）：`TTI指的是用户可以与页面进行交互的时间，即页面变得完全响应用户输入的时间点。较短的TTI可以提高用户的满意度和使用体验。可以通过Chrome开发者工具的Performance面板、Lighthouse等工具来监控和改进TTI，例如通过减少主线程的阻塞、延迟加载非关键资源等来提升TTI。

* `页面体积（Page Size）：`页面体积指的是网页的总大小，包括HTML、CSS、JavaScript、图像、字体等资源的大小。较小的页面体积可以减少页面加载时间和网络流量，提高用户的加载速度和用户体验。可以通过Chrome开发者工具的Network面板、Lighthouse等工具来监控和改进页面体积，例如通过压缩和合并资源、使用适当的图片格式和大小、移除无用的代码等来减小页面体积。

## 性能优化

### 大方向

* `减少 HTTP 请求：`合并和压缩文件可以减少页面加载所需的 HTTP 请求次数。将多个 CSS 文件和 JavaScript 文件合并成一个可以显著减少加载时间。

* `使用 CDN 加速：`使用内容分发网络（CDN）可以将静态资源分发到全球各地的服务器，从而加速页面加载速度。

* `优化图片：`使用适当的图片格式（如 WebP）和压缩图片以减少文件大小。还可以使用 CSS Sprites 或 SVG 精灵表将多个图片合并成一个文件，减少 HTTP 请求。

* `懒加载和预加载：`对于页面上的大型图片或其他资源，使用懒加载来延迟加载，以减少初始页面加载时间。对于某些资源，可以使用预加载来提前加载可能需要的资源，以提高用户体验。

* `优化 CSS 和 JavaScript：`避免使用过多的 CSS 和 JavaScript 库，尽可能精简代码并删除不必要的代码。使用压缩和缩小 JavaScript 和 CSS 文件以减少文件大小。

* `使用缓存：`利用浏览器缓存和服务端缓存来减少重复请求相同资源的次数。可以通过设置合适的缓存头信息来控制资源的缓存策略。

* `减少重绘和回流：`避免频繁修改 DOM 和样式，因为这会触发页面的重绘（Repaint）和回流（Reflow），影响性能。尽可能使用批量操作来减少 DOM 操作次数。

* `使用 Web Workers 和 Service Workers：`将一些计算密集型的任务或网络请求移到后台线程中处理，可以提高页面的响应速度和性能。

* `优化字体加载：`选择适合页面内容和设计风格的字体，并确保字体文件大小合理。使用 Web 字体格式，并通过字体预加载或异步加载来优化字体加载。

* `监控和分析性能：`使用浏览器开发者工具和性能分析工具来监控页面性能，并根据分析结果进行优化。可以关注关键指标，如页面加载时间、首次有效渲染时间（FP）、可交互时间（TTI）等。

### 结合实际

* 比如在移动端

      1、使用路由懒加载：将路由按需加载，可以减少初始加载时需要下载的 JavaScript 文件大小，从而加快页面加载速度。

      2、组件懒加载：对于页面上不常用的组件，可以使用 Vue 的异步组件加载来延迟加载，提高初始渲染速度。

      3、使用虚拟滚动：对于长列表或大量数据的情况，使用虚拟滚动技术（如 vue-virtual-scroller）可以只渲染可视区域内的内容，减少页面渲染所需的资源。

      4、图片优化：使用合适的图片格式和压缩图片以减少页面加载时间。可以使用图片懒加载技术延迟加载图片，或者使用 WebP 格式的图片以提高性能。（比如使用了cover,需要使用gpu加速 translate3d(0,0,0)）
      
      5、代码分割：将项目代码按照业务逻辑拆分成多个模块，只加载当前页面所需的模块，减少初始加载时间。

      6、利用浏览器缓存和服务端缓存来减少重复请求相同资源的次数，减少网络请求时间。

      7、使用工具监控应用的性能指标，分析性能瓶颈，并针对性地进行优化。

      8、使用 Web Workers 和 Service Workers 在后台线程中处理计算密集型任务或网络请求，提高页面性能。

* pc端官网

    `官网建议使用服务端渲染（ssr）`

      1、更快的首屏加载速度：由于服务器端渲染会在服务端生成完整的 HTML 页面，用户访问时能够立即获取到完整的页面内容，从而提升了首屏加载速度。

      2、更好的 SEO：搜索引擎可以直接抓取到服务器端渲染的页面内容，提高了网站的搜索引擎排名。

      3、更友好的用户体验：由于服务器端渲染的页面内容已经准备就绪，用户无需等待客户端应用程序加载和执行 JavaScript 代码，因此能够获得更快的响应速度和更好的用户体验。

      4、适用于弱网环境：在网络环境较差的情况下，服务器端渲染可以提供更好的稳定性和可靠性。

      5、还是可以使用懒加载技术，比如图片懒加载，组件懒加载等。

      6、合并请求，减少请求次数，减少网络请求时间。

## 事件委托

## 垃圾回收机制

  `JavaScript 的垃圾回收机制主要采用的是标记-清除（Mark and Sweep）算法。`

* `标记阶段：`从根对象开始，通过可达性分析，标记所有能够从根对象访问到的对象为活动对象

* `清除阶段：`遍历整个堆，将未被标记的对象视为垃圾，然后清除（释放）这些对象所占用的内存空间。

JavaScript 的垃圾回收器负责在后台运行，周期性地检查内存中的对象，标记并清除不再被引用的对象。这种自动的内存管理机制使得开发者无需手动释放内存，大大简化了内存管理的复杂性，同时也带来了一些性能方面的考量，比如垃圾回收可能会造成一些暂时的停顿，影响程序的响应性。因此，在开发中需要注意避免内存泄漏和过度使用内存等问题，以确保 JavaScript 程序的性能和稳定性。

# h5相关

[移动端适配](#移动端适配)

## 移动端适配

* Viewport 设置：通过 \<meta> 标签设置视口（viewport），以确保网页内容可以正确缩放和适配移动设备的屏幕尺寸。

* 使用相对单位：在 CSS 中使用相对单位（如em、rem、%）来定义尺寸，而不是固定的像素值，以适应不同尺寸的屏幕。

### postcss-to-vw

最终解决方案使用`postcss-to-vw`，将px单位转换为vw单位

 postcss-to-vw实现原理

* `解析 CSS：`首先，插件会使用 PostCSS 解析 CSS 文件，将 CSS 代码转换成抽象语法树（AST）的形式，以便后续处理。

* `遍历 AST：`遍历 CSS 的抽象语法树，寻找到所有的像素单位（px）的值，并将其转换为视窗宽度单位（vw）的值。

* `计算转换：`对于每个像素单位的值，插件会根据视窗的宽度和转换比例计算出对应的视窗宽度单位的值。通常情况下，转换比例是相对于设计稿的宽度，例如设计稿宽度为 750px，转换比例为 1vw = 7.5px。

* `更新 CSS：`将计算出的视窗宽度单位（vw）的值替换掉原来的像素单位（px）的值，并更新 CSS 抽象语法树。

* `生成 CSS：`最后，将更新后的 CSS 抽象语法树重新转换成 CSS 代码，以便输出到最终的 CSS 文件中。
